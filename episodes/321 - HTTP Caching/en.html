<p>HTTP caching involves a cache that is managed through HTTP headers. This cache is often stored in the user&rsquo;s web browser, but not always. If you&rsquo;re unfamiliar with HTTP caching there&rsquo;s an <a href="http://www.mnot.net/cache_docs/">excellent tutorial</a> by Mark Nottingham that goes through the basics and which is well worth taking the time to read.</p> 

<p>This kind of caching can make a web site seem much faster because the browser is reading files from a cache that&rsquo;s close to the user. How can we use this kind of cache to a Rails application? Rails has some HTTP caching enabled by default so let&rsquo;s start by seeing what it provides. We&rsquo;ll use the <code>curl</code> command to see what headers are returned by the response to a request made to a local Rails app running in development mode.</p>

``` terminal
$ curl -I http://localhost:3000/
HTTP/1.1 200 OK 
Content-Type: text/html; charset=utf-8
X-Ua-Compatible: IE=Edge
Etag: "d3132af4f574ff53eb69e6fa5523fe2a"
Cache-Control: max-age=0, private, must-revalidate
X-Request-Id: 2cb31eeec2b1beda8e1342f8caa90acd
X-Runtime: 0.018216
Content-Length: 0
Server: WEBrick/1.3.1 (Ruby/1.9.2/2011-07-09)
Date: Fri, 03 Feb 2012 21:09:22 GMT
Connection: Keep-Alive
Set-Cookie: _store_session=BAh7B0kiD3Nlc3Npb25faWQGOgZFRkkiJWQ2N2U5MGEwMWZhNGU4ZTI2NzIxOTYxOWE1ODYyNzcxBjsAVEkiEF9jc3JmX3Rva2VuBjsARkkiMVhnSG9qT0ZiT0pJYURtNU15WXM0RkRxVUx1V05DZ0F2aFpoMkVIYW85YTA9BjsARg%3D%3D--7cf9c8c8b4f59426186fc8ae01a960a9a02378aa; path=/; HttpOnly
```

<h3>Etag</h3>

<p>The header we&rsquo;ll focus on first is <code>Etag</code>. This header&rsquo;s value is a unique string whose value is based on the content in the response body. If we make a request to the same URL twice and the response body is different the second time then the Etag header will have a different value each time but if the two responses are identical then the Etag values will match. This header is generated by default in a Rails app.</p>

<p>This being the case if we run the <code>curl</code> command above again we might expect to get the same Etag value but this isn&rsquo;t the case.</p>

``` terminal
$ curl -I http://localhost:3000/
HTTP/1.1 200 OK 
Content-Type: text/html; charset=utf-8
X-Ua-Compatible: IE=Edge
Etag: "2022a6964da4596038f5454b1929a2e1"
(rest of headers omitted)
```

<p>The values are different because the response body changes slightly each time we make a request. If we view the source of the page, particularly the head section, we&rsquo;ll see the part that changes.</p>

``` html
<head>
  <title>Store</title>
  <link href="/assets/application.css?body=1" media="all" rel="stylesheet" type="text/css" />
  <link href="/assets/products.css?body=1" media="all" rel="stylesheet" type="text/css" />
  <script src="/assets/jquery.js?body=1" type="text/javascript"></script>
  <script src="/assets/jquery_ujs.js?body=1" type="text/javascript"></script>
  <script src="/assets/products.js?body=1" type="text/javascript"></script>
  <script src="/assets/application.js?body=1" type="text/javascript"></script>
  <meta content="authenticity_token" name="csrf-param" />
  <meta content="wu8YWep8ZJvxAk0mjb0RbMYhVgivucMnorR94grDUnc=" name="csrf-token" />
</head>
```

<p>There&rsquo;s a <code>meta</code> tag in the head section of the page called <code>csrf-token</code>. This tag has a content attribute that contains a unique string which is different for each new visitor. If we reload the page in the browser, however, the value of this attribute remains the same each time. This is because the browser is sent a session cookie to identify its session and this is sent back to the server each time. The <code>curl</code> command doesn&rsquo;t support cookies and so each request will be treated as a separate session and the <code>csrf-token</code>&rsquo;s value will change each time. We can simulate the way a browser works by telling <code>curl</code> to store any cookies sent by the response in a cookie jar.</p> 

``` terminal
$ curl -I http://localhost:3000/ -c cookies.txt
HTTP/1.1 200 OK 
Content-Type: text/html; charset=utf-8
X-Ua-Compatible: IE=Edge
Etag: "10537767ffa7661930cbb10aa243fc9c"
Cache-Control: max-age=0, private, must-revalidate
(rest of headers omitted)
```

<p>We can then send these cookies back with the next request by using <code>curl</code>&rsquo;s -b option. When we do this we should get the same Etag value as before.</p>

``` terminal
$ curl -I http://localhost:3000/ -b cookies.txt
HTTP/1.1 200 OK 
Content-Type: text/html; charset=utf-8
X-Ua-Compatible: IE=Edge
Etag: "10537767ffa7661930cbb10aa243fc9c"
Cache-Control: max-age=0, private, must-revalidate
(rest of headers omitted)
```

<p>This time the two values are the same as the requests are considered to be part of the same session.</p>

<p>So what does this tag have to do with caching? When the browser caches the response it will assign the value of the Etag header to it. If the user requests the same URL again the browser will send the Etag as a header called <code>If-None-Match</code>. If we include this header in the <code>curl</code> command we&rsquo;ll get a different response.</p>

``` terminal
$ curl -I http://localhost:3000/ -b cookies.txt --header 'If-None-Match: "10537767ffa7661930cbb10aa243fc9c"'
HTTP/1.1 304 Not Modified 
X-Ua-Compatible: IE=Edge
Etag: "10537767ffa7661930cbb10aa243fc9c"
Cache-Control: max-age=0, private, must-revalidate
X-Request-Id: 3e97d449f952485c58e84cc72b507c6e
X-Runtime: 0.014820
Server: WEBrick/1.3.1 (Ruby/1.9.2/2011-07-09)
Date: Fri, 03 Feb 2012 21:52:54 GMT
Set-Cookie: _store_session=BAh7B0kiD3Nlc3Npb25faWQGOgZFRkkiJTBiY2NhOGNlNzhjZTIwYzMwZjQxMDhkNjc5ZDdiNWI3BjsAVEkiEF9jc3JmX3Rva2VuBjsARkkiMWZyN0s3VEZWR29VYUR1QlgvRXhZQ1FZNHEzaUtuQkMrc2lWeWUvV250K3c9BjsARg%3D%3D--db383e0d358dc803daa47904f20f47911c235c68; path=/; HttpOnly
```

<p>When we include this header we get a <code>304 Not Modified</code> response instead of <code>200 OK</code>. This tells the browser that its cache is up to date and that it can read the file from there. This makes the site appear much faster to the user as the response is sent from the local cache instead of being downloaded again.</p>

<p>Even though this request now appears quicker to the end user the server still has to generate the full response so that it can generate the Etag to send back and so the request takes as long to process on the server as the  uncached request. This type of caching won&rsquo;t save any resources on the server, it just makes the response appear faster to the user.</p> 

<p>It&rsquo;s possible to make things more efficient on the server by customizing the way an Etag is generated. We&rsquo;ll do this in an application&rsquo;s <code>ProductsController</code>&rsquo;s show action. This is a page that displays information about a single product.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/966/original/E321I01.png" width="800" height="280" alt="The page for a product."/>
</div>

<p>The code for this action looks like this:</p>

```/app/controllers/products_controller.rb
def show
  @product = Product.find(params[:id])
end
```

<p>This is a simple action that fetches a <code>Product</code> by its <code>id</code>. If we know that all of the dynamic content on the page is based on this product we can use it to generate the Etag. To do this we use the <code>fresh_when</code> method and pass it the etag option.</p>

``` /app/controllers/products_controller.rb
def show
  @product = Product.find(params[:id])
  fresh_when etag: @product
end
```

<p>This will generate an Etag header based on that product instead of the page that would be rendered. Internally this will call <code>cache_key</code> on the product to determine the tag&rsquo;s value, which is based on the product&rsquo;s <code>updated_at</code> value. This means that when a product is updated its Etag will change and so any cache based on it will automatically be expired.</p>

<p>The <code>fresh_when</code> method does a couple of things. First it checks that the Etag passed in with the request matches the Etag for the product. If it does then the cache is fresh so the default renderer will be changed to send a <code>304 Not Modified</code> response instead of rendering the actual template for the show action. If the Etags don&rsquo;t match the page will be rendered as normal and returned to the client.</p>

<p>We can try this out with a <code>curl</code> request. We no longer need to send the cookies as the Etag is now dependent on the product and not the response body but we need to change the URL so that it points to the page for a product.</p>

``` terminal
$ curl -I http://localhost:3000/products/1
HTTP/1.1 200 OK 
Etag: "71c9d1d4a8215bd644a5910e17abba30"
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=0, private, must-revalidate
X-Ua-Compatible: IE=Edge
X-Request-Id: b8cc044bdb08d6447d674c00ea976219
X-Runtime: 0.077276
Content-Length: 0
Server: WEBrick/1.3.1 (Ruby/1.9.2/2011-07-09)
Date: Fri, 03 Feb 2012 22:41:44 GMT
Connection: Keep-Alive
Set-Cookie: _store_session=BAh7B0kiD3Nlc3Npb25faWQGOgZFRkkiJWYzNDM2NGUxNTlmZWRmYjBlNzIxN2UwZTAzZWM4NWRlBjsAVEkiEF9jc3JmX3Rva2VuBjsARkkiMW9vWjdRVEdnYml5aDVndGtaUkxFUG1LbDhlbThMOWFOWkU0ejNkVVNZMTg9BjsARg%3D%3D--57ee4b7dd461e0fe728176a4557ff90894842ff5; path=/; HttpOnly
```

<p>When we visit the page again the Etag remains the same as the product hasn&rsquo;t been updated since the last request.</p>

``` terminal
$ curl -I http://localhost:3000/products/1
HTTP/1.1 200 OK 
Etag: "71c9d1d4a8215bd644a5910e17abba30"
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=0, private, must-revalidate
(rest of headers omitted)
```

<p>If we pass this Etag in in an <code>If-None-Match</code> header it will return <code>304 Not Modified</code> but this time the template won&rsquo;t be rendered on the server because of the <code>fresh_when</code> method in the controller.</p>

``` terminal
$ curl -I http://localhost:3000/products/1 --header 'If-None-Match: "71c9d1d4a8215bd644a5910e17abba30"'
HTTP/1.1 304 Not Modified 
Etag: "71c9d1d4a8215bd644a5910e17abba30"
Cache-Control: max-age=0, private, must-revalidate
X-Ua-Compatible: IE=Edge
X-Request-Id: d119bff19b85bd9c8b0f7aac90d57cec
X-Runtime: 0.003060
Server: WEBrick/1.3.1 (Ruby/1.9.2/2011-07-09)
Date: Fri, 03 Feb 2012 22:49:49 GMT
```

<p>We can see this by looking at the development log. This shows that the first request rendered the show template but that because we sent the right Etag value with the second request the show template wasn&rsquo;t rendered and <code>304 Not Modified</code> was returned which saved some processing on the server.</p>

``` terminal
$ tail -n 14 log/development.log 

Started HEAD "/products/1" for 127.0.0.1 at 2012-02-03 22:46:15 +0000
Processing by ProductsController#show as */*
  Parameters: {"id"=>"1"}
  Product Load (0.1ms)  SELECT "products".* FROM "products" WHERE "products"."id" = ? LIMIT 1  [["id", "1"]]
  Rendered products/show.html.erb within layouts/application (1.1ms)
Completed 200 OK in 9ms (Views: 7.6ms | ActiveRecord: 0.1ms)


Started HEAD "/products/1" for 127.0.0.1 at 2012-02-03 22:49:49 +0000
Processing by ProductsController#show as */*
  Parameters: {"id"=>"1"}
  Product Load (0.1ms)  SELECT "products".* FROM "products" WHERE "products"."id" = ? LIMIT 1  [["id", "1"]]
```  
  
<p>The <code>fresh_when</code> method works well in our show action because we&rsquo;re using the default rendering behaviour. If we had a <code>respond_to</code> block in the action&rsquo;s code this approach wouldn&rsquo;t work as well because this explicitly renders something and it won&rsquo;t fall back to the default renderer. For these cases there&rsquo;s a <code>stale?</code> method that we can use. This will handle any explicit rendering if the Etags don&rsquo;t match or return <code>304 Not Modified</code> if they do.</p>

``` /app/controllers/products_controller.rb
def show
  @product = Product.find(params[:id])
  if stale? etag: @product
    respond_to do |format|
      #.....
    end
  end
end
```

<p>We don&rsquo;t need to use this in our <code>show</code> action so we&rsquo;ll stick with <code>fresh_when</code>. One cool feature of it that we&rsquo;ve not mentioned here is that it allows us to pass in an array of multiple objects. If a page&rsquo;s dynamic content is dependent on multiple objects we can pass them in and the Etag will be based on all of them. If we want the Etag to be based on the product and also the current user we could write something like this.</p>

``` /app/controllers/products_controller.rb
def show
  @product = Product.find(params[:id])
  fresh_when etag: [@product, current_user]
end
```

<h3>Last-Modified</h3>

<p>That pretty much covers Etags but there&rsquo;s another header tag that goes with <code>Etag</code> called <code>Last-Modified</code>. Like etag we can set this header through the <code>fresh_when</code> method and when we use it we should set it to the time that the document that&rsquo;s returned was last modified.</p> 

``` /app/controllers/products_controller.rb
def show
  @product = Product.find(params[:id])
  fresh_when etag: @product, last_modified: @product.updated_at
end
```

<p>When we make a request to the product&rsquo;s page now the response will include the <code>Last-Modified</code> header with a value showing the time at which that product was last modified.</p>

``` terminal
$ curl -I http://localhost:3000/products/1
HTTP/1.1 200 OK 
Etag: "71c9d1d4a8215bd644a5910e17abba30"
Last-Modified: Fri, 03 Feb 2012 20:53:43 GMT
(rest of headers omitted)
```

<p>The browser can use this header in a similar way to Etags to determine if its cache is still up to date. It does this by passing in a header option with the request called <code>If-Modified-Since</code>.</p>

``` terminal
$ curl -I http://localhost:3000/products/1 --header 'If-Modified-Since: Fri, 3rd Feb 2012 21:05:03 GMT'
HTTP/1.1 304 Not Modified 
Etag: "71c9d1d4a8215bd644a5910e17abba30"
Last-Modified: Fri, 03 Feb 2012 20:53:43 GMT
(rest of headers omitted)
```

<p>As the page hasn’t been modified since the date we sent in <code>If-Modified-Since</code> we get a <code>304 Not Modified</code> response. If we pass in an time earlier than the time that the product was last modified we’ll get a full <code>200 OK</code> response.</p>

``` terminal
$ curl -I http://localhost:3000/products/1 --header 'If-Modified-Since: Fri, 3rd Feb 2012 20:45:00 GMT'
HTTP/1.1 200 OK 
Etag: "71c9d1d4a8215bd644a5910e17abba30"
Last-Modified: Fri, 03 Feb 2012 20:53:43 GMT
(rest of headers omitted)
```

<p>It&rsquo;s a good idea to set both the <code>etag</code> and <code>last_modified</code> options when you can. If we&rsquo;re using Rails 3.2 we can do this in a more concise way by passing the object directly in to <code>fresh_when</code>.</p>

```/app/controllers/products_controller.rb
def show
  @product = Product.find(params[:id])
  fresh_when @product
end
```

<p>There are some things that we can do with the <code>Last-Modified</code> header that we can&rsquo;t do as easily with <code>Etag</code>. We&rsquo;ll demonstrate this in the <code>index</code> action which displays a list of products. First, a slight tangent on how we go about fetching all the products.</p>

``` /app/controllers/products_controller.rb
def index
  @products = Product.all
end
```

<p>In this action we use <code>Product.all</code> to fetch all the products. This performs the database query immediately in the controller. When we&rsquo;re working with caching we should try to perform the database query as late as possible. We don&rsquo;t need the list of products until they&rsquo;re rendered out in the view and so we shouldn&rsquo;t perform the query here. If we use the order method this will defer the actual query, alternatively we can use scoped to fetch all the products. This is similar to <code>all</code> but doesn&rsquo;t perform the database query until we try to work with the products. We can use this in conjunction with <code>fresh_when</code> to set the <code>Last-Modified-Date</code> to the <code>updated_at</code> time for the most recently updated product.</p>

``` /app/controllers/products_controller.rb
def index
  @products = Product.scoped
  fresh_when last_modified: @products.maximum(:updated_at)
end
```

<p>This code does make a database query but it only fetches one quick value to determine if the cache is up-to-date. If it is then the action doesn&rsquo;t need to render the whole view template and therefore we don&rsquo;t need to fetch all the products from the database. This may or may not give up a big performance boost depending on how many requests come in from browsers that already have this page in their cache. It&rsquo;s always a good idea to test and performance benchmark this kind of change to see if it has any real world benefits.</p>

<h3>Cache-Control</h3>

<p>So far we&rsquo;ve covered two different response headers, <code>Etag</code> and <code>Last-Modified</code>. There&rsquo;s one more that we&rsquo;ll cover in this episode, <code>Cache-Control</code>. We can set a variety of options through this header to determine how the caching should behave.  Rails sets some default values for this header automatically.</p> 

``` text
Cache-Control: max-age=0, private, must-revalidate
```

<p>We&rsquo;ll look at the last value, <code>must-revalidate</code>, first. This value means that the browser should always check with the server before it serves up a page from the cache to ensure that it&rsquo;s serving an up-to-date version. The <code>max-age</code> option specifies the number of seconds for which the cache can be served to the user before the browser contacts the server to revalidate the cache. If this value was set to 30 rather than 0 then the cached file can be served to the user locally for 30 seconds after the file is first downloaded. After that if the page is requested again the browser should contact the server to make sure that the cached version of the page is still valid. We can customize this <code>max-age</code> option by using the <code>expires_in</code> method and passing it a duration.</p>

``` /app/controllers/products_controller.rb
def show
  @product = Product.find(params[:id])
  expires_in 5.minutes
  fresh_when @product
end
```

<p>When we make the same request again now we&rsquo;ll see that the <code>max-age</code> option is now set to 300 seconds.</p>

``` terminal
$ curl -I http://localhost:3000/products/1 --header 'If-Modified-Since: Fri, 3rd Feb 2012 20:45:00 GMT'
HTTP/1.1 200 OK 
Etag: "71c9d1d4a8215bd644a5910e17abba30"
Last-Modified: Fri, 03 Feb 2012 20:53:43 GMT
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=300, private
(rest of headers omitted)
```

<p>This means that the local cache will be considered fresh for 300 seconds. After that the browser will check with the server to see if the page is still valid. If it is then the cached version will be considered valid for another 300 seconds.</p>

<p>We have one more option to cover: <code>private</code>. This value means that the cache should only be stored for this specific user, usually in their web browser, and not  stored in a place where multiple people access it such as through a proxy. We can customize this behaviour in any of the caching methods, in <code>expires_in</code> <code>fresh_when</code> or <code>stale</code>. All we need to do is use the public option and set it to true.</p>

``` /app/controllers/products_controller.rb
def show
  @product = Product.find(params[:id])
  expires_in 5.minutes
  fresh_when @product, public: true
end
```

<p>When we fetch that page again we&rsquo;ll see that the <code>Cache-Control</code> header now says <code>public</code> instead of <code>private</code>.</p>

``` terminal
$ curl -I http://localhost:3000/products/1
HTTP/1.1 200 OK 
Etag: "71c9d1d4a8215bd644a5910e17abba30"
Last-Modified: Fri, 03 Feb 2012 20:53:43 GMT
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=300, public
(rest of headers omitted)
```

<p>This means that this page can be cached in other places beside the user&rsquo;s browser such as in a proxy.</p> 

<h3>Rack::Cache</h3>

<p>Speaking of proxies Rails now automatically includes <a href="http://rtomayko.github.com/rack-cache/">Rack::Cache</a> in production. This is known as a reverse proxy cache or gateway cache but don&rsquo;t let the name confuse you, the core concept is fairly simple. There&rsquo;s an excellent guide by Ryan Tomayko called <a href="http://tomayko.com/writings/things-caches-do">&ldquo;Things Caches Do&rdquo;</a> which explains this nicely. Rack::Cache sits on the server between the users&rsquo; requests and a Rails application. Normally HTTP caches are stored on the user&rsquo;s side in their browser but if Rack::Cache is installed and the cache is marked as <code>public</code> the response will be stored inside Rack::Cache as well. There&rsquo;s a nice example of this in Ryan&rsquo;s article.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/967/original/E321I02.png" width="800" height="603" alt="When Rack::Cache doesn't have a copy of the page the request is passed to the Rails backend"/>
</div>

<p>If Alice makes a request to a server and the response for this request isn&rsquo;t cached the request will pass through Rack::Cache to the Rails backend. The response is tagged with <code>maxage=600</code> so the response is cached for ten minutes and as the cache is marked as public the response will be cached in Rack::Cache too before its sent to Alice.</p>

<p>Let&rsquo;s say that within that ten minutes another user called Bob comes along and he makes the same request. Even though he doesn&rsquo;t have this page cached in his browser Rack::Cache does so the Rails app won&rsquo;t be hit as Rack::Cache knows that its cached version is still fresh.</p>

<div class="imageWrapper">
  <img src="http://asciicasts.com/system/photos/968/original/E321I03.png" width="800" height="603" alt="When Rack::Cache has a fresh copy of the requested resource it will return it."/>
</div>

<p>Rack::Cache also supports the validations of the <code>Last-Modified</code> and <code>Etag</code> headers and there&rsquo;s more information about these in Ryan&rsquo;s article. We can think of Rack::Cache as a mini in-between browser. It will cache just like a browser does but it works for all users and only for public users.</p>

<p>As we mentioned earlier Rack::Cache is only available in production mode by default but if we want to try it out we can enable it in development by setting the <code>perform_caching</code> option to <code>true</code>.</p>

``` /config/environments/development.rb
config.action_controller.perform_caching = true
```

<p>With this option set if we run <code>rake middleware</code> we see that the first piece of middleware in the stack is <code>Rack::Cache</code>.</p>

``` terminal 
$ rake middleware
use Rack::Cache
use ActionDispatch::Static
use Rack::Lock
(rest of stack omitted)
```

<p>We&rsquo;ll need to restart the server after we&rsquo;ve made this change but once we have if we visit the page for a product in a browser Rack::Cache will cache it as we&rsquo;ve set the <code>public</code> option to <code>true</code> in this action. The next time we visit this page it will be server by Rack::Cache instead of from the Rails application.</p>

<h3>Caching Sensitive Data</h3>

<p>While using a public cache can speed up our application we need to be careful. There&rsquo;s a danger of sensitive information on a page or information that changes depending on the user that&rsquo;s visiting the page being cached for every user so that other users see information that they shouldn&rsquo;t. If there&rsquo;s user-specific information on a page we don&rsquo;t want to be stored in a public cache such as the <code>csrf_meta_tag</code> in a layout file. We can hide this dynamically so that it&rsquo;s not shown if the cache for the current response is public.</p>

``` /app/views/layouts/application.html.erb
<%= csrf_meta_tag unless response.cache_control[:public] %>
```

<p>We should do this to the flash messages that are shown, too.</p>
 
``` /app/views/layouts/application.html.erb
<% unless response.cache_control[:public] %>
  <% flash.each do |name, msg| %>
    <%= content_tag :div, msg, id: "flash_#{name}" %>
  <% end %>
<% end %>
```

<p>Now that we know all about these fancy HTTP caching techniques the big question is &ldquo;when should we use it&rdquo;? How do we know what cache to use and when? First of all we should avoid premature optimization and wait until we know which pages are going to be hit often then focus on caching them first. If the page doesn&rsquo;t change frequently and if it doesn&rsquo;t matter if it&rsquo;s a little out of date then the <code>expires_in</code> method is the way to go. This will lead to the fastest user response because the cache doesn&rsquo;t have to be validated against the server. On the other hand if the page changes more frequently the we should consider <code>fresh_when</code> or <code>stale</code> as these gives us more control over when the cache expires. Finally we should only get <code>public</code> to <code>true</code> if we don&rsquo;t have sensitive information on the page.</p>